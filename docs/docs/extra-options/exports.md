# Exports

Bunup automatically generates and updates the `exports` field in your package.json file after each build.

Bunup handles mapping all entry points to their corresponding output files, including ESM/CJS formats and type declarations. The exports field stays perfectly in sync with your build configuration always - no manual updates needed when you make any change to config.

## Usage

Enable exports generation in your Bunup configuration:

::: code-group

```sh [CLI]
bunup --exports
```

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	exports: true,
});
```

:::

This will automatically update your package.json with the correct exports field each time you build. For example:

```json [package.json]
{
	"name": "my-package",
	"version": "1.0.0",
	"type": "module",
	"files": [ // [!code ++]
		"dist" // [!code ++]
	], // [!code ++]
	"module": "./dist/index.js", // [!code ++]
	"main": "./dist/index.cjs", // [!code ++]
	"types": "./dist/index.d.ts", // [!code ++]
	"exports": { // [!code ++]
		".": { // [!code ++]
			"import": { // [!code ++]
				"types": "./dist/index.d.ts", // [!code ++]
				"default": "./dist/index.js" // [!code ++]
			}, // [!code ++]
			"require": { // [!code ++]
				"types": "./dist/index.d.cts", // [!code ++]
				"default": "./dist/index.cjs" // [!code ++]
			} // [!code ++]
		} // [!code ++]
	} // [!code ++]
}
```

## Options

### `customExports`

The `customExports` option allows you to specify additional export fields that will be preserved alongside the automatically generated exports. This is useful when you need custom export conditions or paths that aren't automatically generated by the build process.

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	exports: {
		customExports: (ctx) => ({
			'./package.json': './package.json',
		})
	},
});
```

### `exclude`

The `exclude` option allows you to prevent specific entry points from being included in the exports field. You can provide either an array of glob patterns or exact entry point names, or a function that returns such an array.

::: code-group

```sh [CLI]
# Single exclusion
bunup --exports.exclude=src/utils.ts

# Multiple exclusions  
bunup --exports.exclude=src/utils.ts,src/cli.ts

# Using glob patterns
bunup --exports.exclude="src/cli/*"
```

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	entry: ['src/index.ts', 'src/cli.ts', 'src/utils.ts'],
	exports: {
		exclude: ['src/utils.ts']
	},
});
```

:::

For more dynamic control, you can use a function (config only):

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	entry: ['src/index.ts', 'src/cli.ts', 'src/utils.ts'],
	exports: {
		exclude: (ctx) => {
			// Access build context information
			const { options, output, meta } = ctx;
			return ['src/utils.ts'];
		}
	},
});
```

### `excludeCli`

By default, CLI-related entry points are automatically excluded from the package exports field. This prevents binary/command-line tools from being exposed as importable package exports, which is the correct behavior in most cases since CLI entries are typically used via the `bin` field in package.json.

The plugin uses glob patterns to automatically detect and exclude common CLI entry point patterns:
- Files or directories named `cli` (e.g., `cli.ts`, `cli/index.ts`)
- Files or directories named `bin` (e.g., `bin.ts`, `bin/index.ts`)
- CLI-related paths in any directory (e.g., `src/cli.ts`, `tools/bin/index.ts`)

If you want to include CLI entries in your exports (which is rarely needed), you can disable this behavior:

::: code-group

```sh [CLI]
bunup --no-exports.exclude-cli
```

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	exports: {
		excludeCli: false // Include CLI entries in exports
	},
});
```

:::

When disabled, CLI entries will be treated like any other entry point and included in the exports field.

### `excludeCss`

When you use CSS files and import them in your JavaScript files, Bun will bundle the CSS and include it in the build output. As a result, these CSS files will be automatically added to the exports field with appropriate export keys.

The `excludeCss` option allows you to prevent CSS files from being included in the exports field if you prefer to handle CSS distribution manually or don't want to expose CSS files as part of your package's public API.

::: code-group

```sh [CLI]
bunup --exports.exclude-css
```

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	exports: {
		excludeCss: true
	},
});
```

:::

### `includePackageJson`

By default, exports generation automatically adds `"./package.json": "./package.json"` to your package's exports field. This export is useful for:

- **Package introspection**: Allowing consumers to access your package's metadata programmatically
- **Tooling compatibility**: Many development tools and package managers expect to be able to import package.json
- **Runtime information**: Enabling your package to access its own version and metadata at runtime

The `includePackageJson` option allows you to control this behavior:

::: code-group

```sh [CLI]
bunup --no-exports.include-package-json
```

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	exports: {
		includePackageJson: false // Disable package.json export
	},
});
```

:::

When enabled (default), your exports field will include:

```json [package.json]
{
	"exports": {
		".": {
			"import": "./dist/index.js",
			"types": "./dist/index.d.ts"
		},
		"./package.json": "./package.json" // [!code ++]
	}
}
```

### `all`

The `all` option controls how open your package exports are. This affects what files consumers can import from your package.

When `all: true`, a wildcard subpath export is added that allows importing any file from your package:

::: code-group

```sh [CLI]
bunup --exports.all
```

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';

export default defineConfig({
	exports: {
		all: true
	},
});
```

:::

This generates:

```json [package.json]
{
	"exports": {
		".": {
			"import": "./dist/index.js",
			"types": "./dist/index.d.ts"
		},
		"./*": "./*" // [!code ++]
	}
}
```

With `all: true`, consumers can import any file that ends up in your published package.

::: warning
When using `all: true`, any file that ends up in your published tarball becomes importable. Control what you publish using the `files` field in package.json or `.npmignore` to avoid exposing internal files.
:::
