# Exports

This plugin automatically generates and updates the `exports` field in your package.json file after each build.

Bunup handles mapping all entry points to their corresponding output files, including ESM/CJS formats and type declarations. The exports field stays perfectly in sync with your build configuration always - no manual updates needed when you make any change to config.

## Usage

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: 'src/index.ts',
	plugins: [exports()],
});
```

When using the exports plugin, your package.json will be automatically updated with the correct exports field each time you build. For example:

```json [package.json]
{
	"name": "my-package",
	"version": "1.0.0",
	"type": "module",
	"files": [ // [!code ++]
		"dist" // [!code ++]
	], // [!code ++]
	"module": "./dist/index.js", // [!code ++]
	"main": "./dist/index.cjs", // [!code ++]
	"types": "./dist/index.d.ts", // [!code ++]
	"exports": { // [!code ++]
		".": { // [!code ++]
			"import": { // [!code ++]
				"types": "./dist/index.d.ts", // [!code ++]
				"default": "./dist/index.js" // [!code ++]
			}, // [!code ++]
			"require": { // [!code ++]
				"types": "./dist/index.d.cts", // [!code ++]
				"default": "./dist/index.cjs" // [!code ++]
			} // [!code ++]
		} // [!code ++]
	} // [!code ++]
}
```

## Options

### `customExports`

The `customExports` option allows you to specify additional export fields that will be preserved alongside the automatically generated exports. This is useful when you need custom export conditions or paths that aren't automatically generated by the build process.

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: 'src/index.ts',
	plugins: [
		exports({
			customExports: (ctx) => ({
				'./package.json': './package.json',
			})
		})
	],
});
```

### `exclude`

The `exclude` option allows you to prevent specific entry points from being included in the exports field. You can provide either an array of glob patterns or exact entry point names, or a function that returns such an array.

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: ['src/index.ts', 'src/cli.ts', 'src/utils.ts'],
	plugins: [
		exports({
			exclude: ['src/utils.ts']
		})
	],
});
```

You can also use glob patterns:

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: ['src/index.ts', 'src/cli/*.ts', 'src/plugins.ts'],
	plugins: [
		exports({
			exclude: ['src/cli/*']
		})
	],
});
```

For more dynamic control, you can use a function:

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: ['src/index.ts', 'src/cli.ts', 'src/utils.ts'],
	plugins: [
		exports({
			exclude: (ctx) => {
				// Access build context information
				const { options, output, meta } = ctx;
				return ['src/utils.ts'];
			}
		})
	],
});
```

### `excludeCss`

When you use CSS files and import them in your JavaScript files, Bun will bundle the CSS and include it in the build output. As a result, these CSS files will be automatically added to the exports field with appropriate export keys.

The `excludeCss` option allows you to prevent CSS files from being included in the exports field if you prefer to handle CSS distribution manually or don't want to expose CSS files as part of your package's public API.

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: 'src/index.ts',
	plugins: [
		exports({
			excludeCss: true
		})
	],
});
```

### `includePackageJson`

By default, the exports plugin automatically adds `"./package.json": "./package.json"` to your package's exports field. This export is useful for:

- **Package introspection**: Allowing consumers to access your package's metadata programmatically
- **Tooling compatibility**: Many development tools and package managers expect to be able to import package.json
- **Runtime information**: Enabling your package to access its own version and metadata at runtime

The `includePackageJson` option allows you to control this behavior:

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: 'src/index.ts',
	plugins: [
		exports({
			includePackageJson: false // Disable package.json export
		})
	],
});
```

When enabled (default), your exports field will include:

```json [package.json]
{
	"exports": {
		".": {
			"import": "./dist/index.js",
			"types": "./dist/index.d.ts"
		},
		"./package.json": "./package.json" // [!code ++]
	}
}
```

### `all`

The `all` option controls how open your package exports are. This affects what files consumers can import from your package.

When `all: true`, a wildcard subpath export is added that allows importing any file from your package:

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: 'src/index.ts',
	plugins: [
		exports({
			all: true
		})
	],
});
```

This generates:

```json [package.json]
{
	"exports": {
		".": {
			"import": "./dist/index.js",
			"types": "./dist/index.d.ts"
		},
		"./*": "./*" // [!code ++]
	}
}
```

With `all: true`, consumers can import any file that ends up in your published package:

```js
import pkg from 'your-package'
import utils from 'your-package/dist/utils.js'
import internals from 'your-package/src/internal.js'
```

::: warning
When using `all: true`, any file that ends up in your published tarball becomes importable. Control what you publish using the `files` field in package.json or `.npmignore` to avoid exposing internal files.
:::
